<!--
Sample from the Khronos group:
http://www.damix.it/public/webgl/normal-mapping.html
-->

<html>
  <head>
    <title>Normal Mapping in WebGL</title>

    <script id="vs" type="x-shader/x-vertex">
      attribute vec3 aPositionL;
      attribute vec3 aNormalL;
      attribute vec3 aTangentL;
      attribute vec2 aTexCoord;

      uniform mat4 uMatrixMVP;
      uniform mat4 uMatrixMV;

      varying vec4 vPositionV;
      varying vec3 vNormalV;
      varying vec3 vTangentV;
      varying vec2 vTexCoord;

      void main(void) {
        gl_Position = uMatrixMVP * vec4(aPositionL, 1.0);
        vPositionV = uMatrixMV * vec4(aPositionL, 1.0);
        vNormalV = (uMatrixMV * vec4(aNormalL, 0.0)).xyz;
        vTangentV = (uMatrixMV * vec4(aTangentL, 0.0)).xyz;
        vTexCoord = aTexCoord;
      }
    </script>

    <script id="fs" type="x-shader/x-fragment">
      #ifdef GL_ES
      precision highp float;
      #endif

      uniform sampler2D uColorSampler;
      uniform sampler2D uNormalSampler;
      uniform float uTime;

      varying vec4 vPositionV;
      varying vec3 vNormalV;
      varying vec3 vTangentV;
      varying vec2 vTexCoord;

      void main(void) {
        vec3 diffuse = texture2D(uColorSampler, vTexCoord).rgb;
        vec3 normalT = texture2D(uNormalSampler, vTexCoord).xyz;
        normalT.y = 1.0 - normalT.y;
        normalT = 2.0 * normalT - vec3(1.0, 1.0, 1.0);
        normalT.z *= 10.0;

        vec3 binormalV = cross(vNormalV, vTangentV);
        vec3 normalV = normalT.x * vTangentV + normalT.y * binormalV + normalT.z * vNormalV;

        normalV = normalize(normalV);
        vec3 lightV = normalize(vec3(10.0 * cos(uTime), 10.0, 10.0 * sin(uTime)));

        float d = dot(normalV, lightV);
        float s = dot(reflect(-lightV, normalV), normalize(-vPositionV.xyz));
        s = pow(s, 30.0);

        vec3 color = diffuse * (0.1 + 0.5 * d + 0.4 * s);

        gl_FragColor = vec4(color, 1.0);
      }
    </script>

    <script type="text/javascript">

      var gl;
      var boxPositionBuffer;
      var boxNormalBuffer;
      var boxTangentBuffer;
      var boxTexCoordBuffer;
      var boxElementBuffer;
      var shaderProgram;
      var colorMap;
      var normalMap;
      var elapsed = 0.0;

      function bodyLoad() {

        var mainCanvas = document.getElementById('mainCanvas');

        gl = mainCanvas.getContext('experimental-webgl');
        gl.width = mainCanvas.width;
        gl.height = mainCanvas.height;

        initBuffers();
        initShaders();
        initTextures();

        gl.clearColor(0.2, 0.3, 0.5, 1.0);
        gl.clearDepth(1.0);
        gl.depthFunc(gl.LEQUAL);
        gl.enable(gl.DEPTH_TEST);
        gl.frontFace(gl.CCW);
        gl.cullFace(gl.BACK);

        setInterval(drawScene, 50);
      }

      function initBuffers() {

        // ***** Position *****
        boxPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, boxPositionBuffer);

        var positions = [
          -10.0, 0.0, 10.0,
          10.0, 0.0, 10.0,
          -10.0, 0.0, -10.0,
          10.0, 0.0, -10.0
        ];

        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
        boxPositionBuffer.count = 4;

        // ***** Normal *****
        boxNormalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, boxNormalBuffer);

        var normals = [
          0.0, 1.0, 0.0,
          0.0, 1.0, 0.0,
          0.0, 1.0, 0.0,
          0.0, 1.0, 0.0
        ];

        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
        boxNormalBuffer.count = 4;

        // ***** Tangent *****
        boxTangentBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, boxTangentBuffer);

        var tangents = [
          2.0, 0.0, 0.0,
          2.0, 0.0, 0.0,
          2.0, 0.0, 0.0,
          2.0, 0.0, 0.0
        ];

        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(tangents), gl.STATIC_DRAW);
        boxTangentBuffer.count = 4;

        // ***** TexCoord *****
        boxTexCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, boxTexCoordBuffer);

        var texCoords = [
          0.0, 0.0,
          10.0, 0.0,
          0.0, 10.0,
          10.0, 10.0
        ];

        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords), gl.STATIC_DRAW);
        boxTexCoordBuffer.count = 4;

        // ***** Element *****
        boxElementBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, boxElementBuffer);

        var elements = [
          0, 1, 2, 3
        ];

        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(elements), gl.STATIC_DRAW);
        boxElementBuffer.count = 4;
      }

      function initShaders() {

        var vs = getShader('vs');
        var fs = getShader('fs');

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vs);
        gl.attachShader(shaderProgram, fs);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
          alert('Could not link the shader program.');
          return;
        }

        gl.useProgram(shaderProgram);

        shaderProgram.aPositionL = gl.getAttribLocation(shaderProgram, 'aPositionL');
        gl.enableVertexAttribArray(shaderProgram.aPositionL);
        shaderProgram.aNormalL = gl.getAttribLocation(shaderProgram, 'aNormalL');
        gl.enableVertexAttribArray(shaderProgram.aNormalL);
        shaderProgram.aTangentL = gl.getAttribLocation(shaderProgram, 'aTangentL');
        gl.enableVertexAttribArray(shaderProgram.aTangentL);
        shaderProgram.aTexCoord = gl.getAttribLocation(shaderProgram, 'aTexCoord');
        gl.enableVertexAttribArray(shaderProgram.aTexCoord);
        shaderProgram.uMatrixMVP = gl.getUniformLocation(shaderProgram, 'uMatrixMVP');
        shaderProgram.uMatrixMV = gl.getUniformLocation(shaderProgram, 'uMatrixMV');
        shaderProgram.uColorSampler = gl.getUniformLocation(shaderProgram, 'uColorSampler');
        shaderProgram.uNormalSampler = gl.getUniformLocation(shaderProgram, 'uNormalSampler');
        shaderProgram.uTime = gl.getUniformLocation(shaderProgram, 'uTime');
      }

      function initTextures() {

        colorMap = gl.createTexture();
        colorMap.image = new Image();
        colorMap.image.onload = function() {
          gl.bindTexture(gl.TEXTURE_2D, colorMap);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, colorMap.image);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR_MIPMAP_LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
          gl.generateMipmap(gl.TEXTURE_2D);
          gl.bindTexture(gl.TEXTURE_2D, null);
        };
        colorMap.image.src = 'images/8871-diffuse.jpg';

        normalMap = gl.createTexture();
        normalMap.image = new Image();
        normalMap.image.onload = function() {
          gl.bindTexture(gl.TEXTURE_2D, normalMap);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, normalMap.image);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR_MIPMAP_LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
          gl.generateMipmap(gl.TEXTURE_2D);
          gl.bindTexture(gl.TEXTURE_2D, null);
        };
        normalMap.image.src = 'images/8871-normal.jpg';
      }

      function getShader(id) {

        var shaderScript = document.getElementById(id);

        var k = shaderScript.firstChild;
        var source = '';

        while (k) {
          if (k.nodeType == 3)
            source += k.textContent;

          k = k.nextSibling;
        }

        var shader;

        if (shaderScript.type == 'x-shader/x-vertex') {
          shader = gl.createShader(gl.VERTEX_SHADER);
        }
        else if (shaderScript.type == 'x-shader/x-fragment') {
          shader = gl.createShader(gl.FRAGMENT_SHADER);
        }
        else
          return null;

        gl.shaderSource(shader, source);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          alert(gl.getShaderInfoLog(shader));
          return null;
        }

        return shader;
      }

      function drawScene() {

        elapsed += 0.050;

        gl.viewport(0, 0, gl.width, gl.height);

        var mv = MatrixTranslate(0.0, -1.20, -2.5);
        var p = MatrixFrustum(-1.0, 1.0, -1.0, 1.0, 1.0, 100.0);
        var mvp = mul(p, mv);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, colorMap);
        gl.uniform1i(shaderProgram.uColorSampler, 0);
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, normalMap);
        gl.uniform1i(shaderProgram.uNormalSampler, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.bindBuffer(gl.ARRAY_BUFFER, boxPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.aPositionL, 3, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, boxNormalBuffer);
        gl.vertexAttribPointer(shaderProgram.aNormalL, 3, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, boxTangentBuffer);
        gl.vertexAttribPointer(shaderProgram.aTangentL, 3, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, boxTexCoordBuffer);
        gl.vertexAttribPointer(shaderProgram.aTexCoord, 2, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_ELEMENT_BUFFER, boxElementBuffer);
        gl.uniformMatrix4fv(shaderProgram.uMatrixMVP, false, MatrixToFloat32Array(MatrixTranspose(mvp)));
        gl.uniformMatrix4fv(shaderProgram.uMatrixMV, false, MatrixToFloat32Array(MatrixTranspose(mv)));
        gl.uniform1f(shaderProgram.uTime, elapsed);
        gl.drawElements(gl.TRIANGLE_STRIP, boxElementBuffer.count, gl.UNSIGNED_SHORT, 0);
      }

      function MatrixTranslate(dx, dy, dz) {
        return [
          [1, 0, 0, dx],
          [0, 1, 0, dy],
          [0, 0, 1, dz],
          [0, 0, 0, 1]
        ];
      }

      function MatrixFrustum(l, r, b, t, n, f) {
        return [
          [(2*n)/(r-l), 0, (r+l)/(r-l), 0],
          [0, (2*n)/(t-b), (t+b)/(t-b), 0],
          [0, 0, -(f+n)/(f-n), -2*(f*n)/(f-n)],
          [0, 0, -1, 0]
        ];
      }

      function MatrixIdentity() {
        return [
          [1, 0, 0, 0],
          [0, 1, 0, 0],
          [0, 0, 1, 0],
          [0, 0, 0, 1]
        ];
      }

      function MatrixScale(sx, sy, sz) {
        return [
          [sx, 0, 0, 0],
          [0, sy, 0, 0],
          [0, 0, sz, 0],
          [0, 0, 0, 1]
        ];
      }

      function MatrixZero() {
        return [
          [0, 0, 0, 0],
          [0, 0, 0, 0],
          [0, 0, 0, 0],
          [0, 0, 0, 0]
        ];
      }

      function MatrixTranspose(M) {
        var T = [M[0].slice(), M[1].slice(), M[2].slice(), M[3].slice()];

        for (var i = 0; i < 4; ++i) {
          for (var j = i + 1; j < 4; ++j) {
            var tmp = T[i][j];
            T[i][j] = T[j][i];
            T[j][i] = tmp;
          }
        }

        return T;
      }

      function MatrixToFloat32Array(M) {
        var arr = new Array();

        arr = arr.concat(M[0], M[1], M[2], M[3]);
        //document.getElementById('spanMsg').innerHTML = arr.length;

        return new Float32Array(arr);
      }

      function mul(A, B) {
        var C = MatrixZero();

        for (var i = 0; i < 4; ++i) {
          for (var j = 0; j < 4; ++j) {
            for (var k = 0; k < 4; ++k) {
              C[i][j] += A[i][k] * B[k][j];
            }
          }
        }

        return C;
      }

    </script>
  </head>

  <body onload="bodyLoad();">
    <img src="webgl_logo.gif"/>
    <div style="text-align:center;font-family:sans-serif;">
      If you can't see anything then you should download and properly configure a compatible browser.
      <br/>This example was developed and tested on
      <a href="http://tools.google.com/dlpage/chromesxs">Google Chrome Canary Build</a>
      (Windows only).
      <br/>
      You can get this to run on Firefox by following
      <a href="http://blog.vlad1.com/2009/09/18/webgl-in-firefox-nightly-builds/">these instructions</a>.
      <br/>
      <a href="http://www.chromium.org/getting-involved/dev-channel">Other Chrome builds</a>
      may be available for your operating system which support WebGL<sup>TM</sup>.
      <br/></br>
      <cite>WebGL and the WebGL logo are trademarks of the Khronos Group Inc.</cite>
    </div>
    <br/>
    <div style="text-align:center;">
      <canvas id="mainCanvas" width="640" height="480"/>
    </div>
  </body>
</html>
